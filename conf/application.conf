# This is the main configuration file for the application.
# ~~~~~

# Secret key
# ~~~~~
# The secret key is used to secure cryptographics functions.
#
# This must be changed for production, but we recommend not changing it in this file.
#
# See http://www.playframework.com/documentation/latest/ApplicationSecret for more details.
play.crypto.secret="ZUUv]Jd63g]uB6r<5fM:@LNaoaKGytj1]Ur94;q^G]Xeod]U=uyy=0CX^WkD:eO`"


# The application languages
# ~~~~~
play.i18n.langs = ["cn", "kr" , "en"]

# modules
#play.modules.enabled += "modules.MyBatisModule"
#play.modules.enabled += "modules.BinderModule"

play.http.filters=filters.Filters

play.modules.enabled += "modules.StyleDBModule"
play.modules.enabled += "modules.AccountDBModule"
play.modules.enabled += "modules.OSSModule"
# Global object class
# ~~~~~
# Define the Global object class for this application.
# Default to Global in the root package.
//application.global = filter.Global

#application.global = filter.GlobalFilter

# Router
# ~~~~~
# Define the Router object to use for this application.
# This router will be looked up first when the application is starting up,
# so make sure this is the entry point.
# Furthermore, it's assumed your route file is named properly.
# So for an application router like `my.application.Router`,
# you may need to define a router file `conf/my.application.routes`.
# Default to routes in the root package (and conf/routes)
# play.http.router = my.application.routes

# Database configuration
# ~~~~~
# You can declare as many datasources as you want.
# By convention, the default datasource is named `default`
#
db.default.driver=org.postgresql.Driver
db.default.url="jdbc:postgresql://172.28.3.17:5432/style"
db.default.username=postgres
db.default.password="postgres"

# If enabled, log SQL statements being executed.
db.default.logStatements=true

db.account.driver=org.postgresql.Driver
db.account.url="jdbc:postgresql://172.28.3.17/account"
db.account.username=postgres
db.account.password="postgres"
db.account.logStatements=true

db.products.driver=org.postgresql.Driver
db.products.url="jdbc:postgresql://172.28.3.17/products"
db.products.username=postgres
db.products.password="postgres"

#
# You can expose this datasource via JNDI if needed (Useful for JPA)
# db.default.jndiName=DefaultDS

# Evolutions
# ~~~~~
# You can disable evolutions if needed
# play.evolutions.enabled=false

# You can disable evolutions for a specific datasource if necessary
# play.evolutions.db.default.enabled=false


#server url config
image.server.url = "http://172.28.3.18:3008"
deploy.server.url = "http://172.28.3.18:9001"

#cache
play.modules.enabled+="com.github.mumoshu.play2.memcached.MemcachedModule"
play.modules.disabled+="play.api.cache.EhCacheModule"

# Well-known configuration provided by Play
play.modules.cache.defaultCache=default
play.modules.cache.bindCaches=["db-cache", "user-cache", "session-cache"]
memcached.host="172.28.3.13:11211" #memcached host配置

oss.access_key=gXc1BHNhQmRXkgHz
oss.access_secret=FGWOvCgwFxH1lPxR42eQnqDUwXYKun
oss.endpoint="http://oss-cn-beijing.aliyuncs.com"
oss.bucket=wodeshouyou-test

play.filters {

  # CSRF config
  csrf {

    # Token configuration
    token {
      # The token name
      name = "csrfToken"

      # Whether tokens should be signed or not
      sign = true
    }

    # Cookie configuration
    cookie {
      # If non null, the CSRF token will be placed in a cookie with this name
      name = null

      # Whether the cookie should be set to secure
      secure = ${play.http.session.secure}

      # Whether the cookie should have the HTTP only flag set
      httpOnly = false
    }

    # How much of the body should be buffered when looking for the token in the request body
    body.bufferSize = ${play.http.parser.maxMemoryBuffer}

    # Header configuration
    header {

      # The name of the header to accept CSRF tokens from.
      name = "Csrf-Token"

      # Whether simple tokens in the header should allow CSRF checks to be bypassed.
      bypass = true
    }

    # Method lists
    method {
      # If non empty, then requests will be checked if the method is not in this list.
      whiteList = []

      # The black list is only used if the white list is empty.
      # Only check methods in this list.
      blackList = ["POST"]
    }

    # Content type lists
    contentType {
      # If non empty, then requests will be checked if the content type is not in this list.
      whiteList = []

      # The black list is only used if the white list is empty.
      # Only check content types in this list.
      blackList = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]
    }

    # The error handler.
    # Used by Play's built in DI support to locate and bind a request handler.  Must be one of the following:
    # - A FQCN that implements play.filters.csrf.CSRF.ErrorHandler (Scala).
    # - A FQCN that implements play.filters.csrf.CSRFErrorHandler (Java).
    # - provided, indicates that the application has bound an instance of play.filters.csrf.CSRF.ErrorHandler through some
    #   other mechanism.
    # If null, will attempt to load a class called CSRFErrorHandler in the root package, otherwise if that's
    # not found, will default to play.filters.csrf.CSRF.CSRFHttpErrorHandler, which delegates to the configured
    # HttpRequestHandler.
    errorHandler = null
  }

  # Security headers filter configuration
  headers {

    # The X-Frame-Options header. If null, the header is not set.
    frameOptions = "DENY"

    # The X-XSS-Protection header. If null, the header is not set.
    xssProtection = "1; mode=block"

    # The X-Content-Type-Options header. If null, the header is not set.
    contentTypeOptions = "nosniff"

    # The X-Permitted-Cross-Domain-Policies header. If null, the header is not set.
    permittedCrossDomainPolicies = "master-only"

    # The Content-Security-Policy header. If null, the header is not set.
    contentSecurityPolicy = "default-src 'self'"
  }

  # CORS filter configuration
  cors {

    # The path prefixes to filter.
    pathPrefixes = ["/"]

    # The allowed origins. If null, all origins are allowed.
    allowedOrigins = null

    # The allowed HTTP methods. If null, all methods are allowed
    allowedHttpMethods = null

    # The allowed HTTP headers. If null, all headers are allowed.
    allowedHttpHeaders = null

    # The exposed headers
    exposedHeaders = []

    # Whether to support credentials
    supportsCredentials = true

    # The maximum amount of time the CORS meta data should be cached by the client
    preflightMaxAge = 1 hour
  }

  # GZip filter configuration
  gzip {

    # The buffer size to use for gzipped bytes
    bufferSize = 8k

    # The maximum amount of content to buffer for gzipping in order to calculate the content length before falling back
    # to chunked encoding.
    chunkedThreshold = 100k

  }
}

